import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  let response = NextResponse.next({ request: { headers: request.headers } })

  // Validação das variáveis de ambiente
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

  // Se as variáveis não estiverem definidas, redireciona para login
  if (!supabaseUrl || !supabaseAnonKey) {
    if (pathname !== '/login') {
      return NextResponse.redirect(new URL('/login', request.url))
    }
    return response
  }

  try {
    const supabase = createServerClient(
      supabaseUrl,
      supabaseAnonKey,
      {
        cookies: {
          get(name: string) { return request.cookies.get(name)?.value },
          set(name: string, value: string, options: CookieOptions) {
            request.cookies.set({ name, value, ...options })
            response = NextResponse.next({ request: { headers: request.headers } })
            response.cookies.set({ name, value, ...options })
          },
          remove(name: string, options: CookieOptions) {
            request.cookies.set({ name, value: '', ...options })
            response = NextResponse.next({ request: { headers: request.headers } })
            response.cookies.set({ name, value: '', ...options })
          },
        },
      }
    )

    // Atualiza a sessão e verifica o usuário com timeout explícito
    const getUserPromise = supabase.auth.getUser()
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout ao conectar com Supabase')), 5000)
    )
    
    let user, authError
    try {
      const result = await Promise.race([getUserPromise, timeoutPromise]) as any
      user = result?.data?.user
      authError = result?.error
    } catch (timeoutError: any) {
      console.error('Middleware Supabase timeout:', timeoutError.message)
      if (pathname !== '/login') {
        return NextResponse.redirect(new URL('/login', request.url))
      }
      return response
    }
    
    // Se houver erro ou não conseguir conectar, permite apenas login
    if (authError) {
      console.error('Middleware Supabase error:', authError.message)
      if (pathname !== '/login') {
        return NextResponse.redirect(new URL('/login', request.url))
      }
      return response
    }

    const userEmail = user?.email
    const isAdmin = userEmail === 'admin@p2p.com'

    // Redirecionamentos Inteligentes (Lógica de Auth)
    if (user && pathname === '/login') {
      return NextResponse.redirect(new URL(isAdmin ? '/admin' : '/cliente', request.url))
    }

    if (!user && pathname !== '/login') {
      return NextResponse.redirect(new URL('/login', request.url))
    }

    if (pathname.startsWith('/admin') && !isAdmin) {
      return NextResponse.redirect(new URL('/cliente', request.url))
    }

    return response
  } catch (error: any) {
    // Em caso de erro inesperado, redireciona para login
    console.error('Middleware error:', error?.message || error)
    if (pathname !== '/login') {
      return NextResponse.redirect(new URL('/login', request.url))
    }
    return response
  }
}

export const config = {
  /* Otimizado: Ignora arquivos estáticos e imagens. 
     Removemos o Webhook daqui se ele não precisar de autenticação Supabase,
     deixando ele passar direto pelo Next.js sem processar o middleware.
  */
  matcher: [
    '/admin/:path*', 
    '/cliente/:path*', 
    '/login',
    '/((?!_next/static|_next/image|favicon.ico|api/asaas/webhook).*)'
  ],
}